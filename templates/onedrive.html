
    <script>
    // Fixed initial folder id for both save flows
    const FIXED_START = "01URYU5JOWFGM7H5QYZNBIIMMFCSQLV6BK";

    // Unified resolver for initial folder id used by the picker
    function getInitFolderId() {
      try {
        if (window.INIT_FOLDER_ID && typeof window.INIT_FOLDER_ID === 'string') return window.INIT_FOLDER_ID;
        if (window.DEFAULT_START_FOLDER && typeof window.DEFAULT_START_FOLDER === 'string') return window.DEFAULT_START_FOLDER;
        return 'root';
      } catch(e) { return 'root'; }
    }
    </script>
    <!doctype html>
<meta charset="utf-8" />
<title>OneDrive ä¿å­˜ï¼ˆçµ„ç¹”å°‚ç”¨ãƒ”ãƒƒã‚«ãƒ¼ + æ–°è¦ãƒ•ã‚©ãƒ«ãƒ€ï¼‰</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="data:,">
<style>
  :root{ --fg:#1f2937; --muted:#6b7280; --line:#e5e7eb; --bg:#fff; --primary:#0b5; --sel:#e6f3ff; --selborder:#9cc7ff; }
  body{font:13px/1.5 ui-sans-serif,system-ui,Segoe UI,Helvetica,Arial;
       color:var(--fg); max-width:900px; margin:20px auto; padding:0 10px;}
  h1{font-size:18px;margin:0 0 8px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:8px 0}
  .col{display:flex;flex-direction:column;gap:4px;min-width:260px;flex:1}
  label.small{font-size:12px;color:var(--muted)}
  input[type=text]{flex:1;min-width:240px;padding:6px 8px;border:1px solid var(--line);border-radius:8px}
  button{padding:8px 10px;border:1px solid var(--line);border-radius:8px;background:#fff;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  .pill{padding:4px 8px;border:1px solid #e8e8ff;background:#f7f7ff;border-radius:999px}
  .badge{padding:2px 8px;border-radius:999px;background:#eef;color:#224;font-weight:600}
  .muted{color:var(--muted)}
  #log{white-space:pre-wrap;background:#fafafa;border:1px solid #eee;padding:10px;min-height:120px}

  /* ãƒ”ãƒƒã‚«ãƒ¼ */
  .picker-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;z-index:9999}
  .picker-panel{width:min(560px,92vw);background:var(--bg);border-radius:14px;box-shadow:0 10px 24px rgba(0,0,0,.20);overflow:hidden}
  .picker-head{display:flex;align-items:center;gap:6px;padding:8px 10px;border-bottom:1px solid var(--line)}
  .picker-title{font-weight:700;margin-right:auto}
  .picker-toolbar{display:flex;gap:6px}
  .picker-body{padding:0;max-height:60vh;overflow:auto}
  .picker-breadcrumb{display:flex;gap:4px;align-items:center;flex-wrap:wrap;padding:6px 10px;border-bottom:1px solid var(--line);background:#fafafa}
  .crumb{color:#2563eb;cursor:pointer}
  .crumb::after{content:"â€º";margin:0 4px;color:#9ca3af}
  .crumb:last-child{font-weight:700;color:var(--fg)}
  .crumb:last-child::after{content:""}
  .list{width:100%;padding:8px}
  .th,.tr{display:grid;grid-template-columns: 1fr 168px;gap:8px;align-items:center}
  .th{padding:0 6px 6px;color:var(--muted);font-weight:600;border-bottom:1px solid var(--line)}
  .tr{padding:2px 6px}
  .rowbox{display:flex;align-items:center;gap:8px;border:1px solid var(--line);border-radius:10px;padding:6px 8px;min-height:34px}
  .tr:hover .rowbox{background:#f8faff}
  .rowbox.selected{ background: var(--sel); border-color: var(--selborder); }
  .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .act{display:inline-flex;gap:6px;justify-content:flex-end;align-items:center}
  .act > button{padding:6px 8px;line-height:1;border-radius:8px}
  .ok{background:var(--primary);color:#fff;border-color: var(--primary)}
  .picker-foot{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-top:1px solid var(--line)}
  .path{font-family:ui-monospace,Menlo,Consolas,monospace;color:#555;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:62%}

  /* ç¸¦ä¸¦ã³ */
  .vertical{flex-direction:column;align-items:flex-start;gap:8px}

  /* è¦ªã¸ãƒœã‚¿ãƒ³éè¡¨ç¤ºï¼ˆæ—¢å­˜ç¶­æŒï¼‰ */
  #btnUp { display: none !important; }

  /* å¼·åˆ¶ä»˜ä¸ãƒ’ãƒ³ãƒˆã‚’UIã‹ã‚‰éš ã™ï¼ˆæ—¢å­˜ç¶­æŒï¼‰ */
  #nm_eml_hint, #nm_xlsx_hint { display: none !important; }

  /* ãƒ•ã‚©ãƒ«ãƒ€æ¤œç´¢ãƒãƒ¼ */
  .picker-search{display:none;gap:6px;align-items:center;padding:8px 10px;border-bottom:1px solid var(--line);background:#f9fafb}
  .picker-search.show{display:flex}
  #folderSearch{flex:1;min-width:120px;padding:6px 8px;border:1px solid var(--line);border-radius:8px}
  .search-hint{font-size:12px;color:#6b7280}
  mark{background:#ffe58f;border-radius:4px;padding:0 2px}

  /* --- additions (Home button & layout fixes) --- */
  .picker-breadcrumb{ display:none !important; }
  #currentPath{ display:none !important; }
  .picker-foot{ justify-content:flex-end !important; }
  .picker-foot > div{ display:flex; gap:8px; }

/* Save button visual states */
#pickerSave.btn-wait { opacity: .5; cursor: not-allowed; filter: grayscale(0.3); }
#pickerSave.btn-ready { opacity: 1; cursor: pointer; }


  /* --- Loading UI (B plan): skeleton rows & overlay spinner --- */
  #loadingOverlay {
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    background: rgba(255,255,255,0.6);
    z-index: 5;
  }
  #loadingOverlay.show { display: flex; }
  #loadingOverlay .spinner {
    width: 30px; height: 30px;
    border: 3px solid #ccc;
    border-top-color: #1e90ff;
    border-radius: 50%;
    animation: spin .8s linear infinite;
    margin-bottom: 8px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .skeleton-row {
    height: 24px;
    background: linear-gradient(90deg, #eee, #f8f8f8, #eee);
    background-size: 200px 100%;
    border-radius: 6px;
    margin: 6px 0;
    animation: shimmer 1.2s infinite;
  }
  @keyframes shimmer {
    0% { background-position: -200px 0; }
    100% { background-position: 200px 0; }
  }

</style>

<h1>OneDrive ä¿å­˜ <span class="badge">çµ„ç¹”ãƒ¢ãƒ¼ãƒ‰</span></h1>
<p class="muted">Graph APIï¼ˆã‚¢ãƒ—ãƒªæ¨©é™ï¼‰ã§ä¿å­˜ã€‚ãƒ•ã‚©ãƒ«ãƒ€ã¯è‡ªå‰ãƒ”ãƒƒã‚«ãƒ¼ã€‚</p>

<!-- ãƒ™ãƒ¼ã‚¹åå…¥åŠ› -->
<div class="row vertical">
  <div class="col">
    <label class="small">AIä½œæˆæœ¬æ–‡ï¼ˆ.emlï¼‰ã®ãƒ™ãƒ¼ã‚¹å</label>
    <input id="emlBase" type="text" placeholder="Report">
    <div class="muted" id="nm_eml_hint"></div>
  </div>
  <div class="col">
    <label class="small">æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ™ãƒ¼ã‚¹åï¼ˆæ‹¡å¼µå­ã¯æ·»ä»˜ã®ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚’å¼·åˆ¶ä»˜ä¸ï¼è¤‡æ•°æ™‚ã¯ãã®ã¾ã¾ï¼‰</label>
    <input id="xlsxBase" type="text" placeholder="Attachment">
    <div class="muted" id="nm_xlsx_hint"></div>
  </div>
</div>

<!-- æ“ä½œ -->
<div class="row">
  <button id="openPicker">ğŸ“ ç·¨é›†ã›ãšã«ä¿å­˜</button>
  <span id="pickedHint" class="pill"></span>
</div>

<h3>ãƒ­ã‚°</h3>
<pre id="log"></pre>

<!-- è‡ªå‰ãƒ•ã‚©ãƒ«ãƒ€ãƒ”ãƒƒã‚«ãƒ¼ -->
<div id="picker" class="picker-backdrop" style="display:none" role="dialog" aria-modal="true">
<div id="loadingOverlay"><div class="spinner"></div><p>èª­ã¿è¾¼ã¿ä¸­...</p></div>

  <div class="picker-panel">
    <div class="picker-head">
      <div class="picker-title">ä¿å­˜å…ˆã‚’é¸æŠ</div>
      <div class="picker-toolbar">
        <button id="btnHome" aria-label="ãƒ«ãƒ¼ãƒˆã¸">ğŸ  ãƒ«ãƒ¼ãƒˆ</button>
        <button id="btnSearchToggle">ğŸ” æ¤œç´¢</button>
        <button id="btnBack">â† æˆ»ã‚‹</button>
        <button id="btnUp">â†‘ è¦ªã¸</button>
        <button id="btnNewFolder">ï¼‹ æ–°è¦ãƒ•ã‚©ãƒ«ãƒ€</button>
        <button id="btnReload">âŸ³ æ›´æ–°</button>
      </div>
    </div>
    <div class="picker-search" id="pickerSearchBar">
      <input id="folderSearch" type="text" placeholder="ãƒ•ã‚©ãƒ«ãƒ€åã‚’æ¤œç´¢ï¼ˆç¾åœ¨ã®éšå±¤å†…ï¼‰" aria-label="ãƒ•ã‚©ãƒ«ãƒ€åã‚’æ¤œç´¢">
      <button id="btnSearchClear" title="ã‚¯ãƒªã‚¢">âœ•</button>
      <div class="search-hint">Enterã§æ±ºå®šã€Escã§é–‰ã˜ã‚‹</div>
    </div>
    <div class="picker-breadcrumb" id="crumbs"></div>
    <div class="picker-body">
      <div class="th"><div>åå‰</div><div style="text-align:right">æ“ä½œ</div></div>
      <div id="list" class="list"></div>
    </div>
    <div class="picker-foot">
      <div class="path" id="currentPath">/</div>
      <div>
        <button id="pickerCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="pickerSave" class="ok" disabled>ä¿å­˜</button>
      </div>
    </div>
  </div>
</div>

<script>

// --- early helpers to avoid ReferenceError before main helpers are defined ---
function setSaveState(state){
  const btn = $("pickerSave");
  if (!btn) return;
  if (state === "ready") {
    btn.disabled = false;
    btn.classList.remove("btn-wait");
    btn.classList.add("btn-ready");
  } else {
    btn.disabled = true;
    btn.classList.remove("btn-ready");
    btn.classList.add("btn-wait");
  }
}
function updateSaveState(){
  const btn = $("pickerSave");
  if (!btn) return;
  const nav = (typeof isNavigating !== "undefined" ? isNavigating : false);
  const loading = (typeof isLoading !== "undefined" ? isLoading : false);
  const hasPicked = !!(typeof pickedFolderId !== "undefined" && pickedFolderId);
  if (nav) { setSaveState("waiting"); return; }
  if (hasPicked) { setSaveState("ready"); return; }
  setSaveState(loading ? "waiting" : "ready");
}
function setPickedHint(){
  try{
    const name = pickedFolderName || ((breadcrumb && breadcrumb.length) ? (breadcrumb[breadcrumb.length-1].name || "/") : "/");
    $("pickedHint").textContent = "ä¿å­˜å…ˆ: " + (name || "/");
  }catch(e){ /* no-op */ }
}

const $ = (id)=>document.getElementById(id);
const log = (m)=>{ $("log").textContent += m + "\n"; };

// ===== ã‚¯ã‚¨ãƒªåˆæœŸåŒ– =====
const q = new URLSearchParams(location.search);
const T_EML   = q.get("ticket_eml")   || "";
const T_XLSX  = q.get("ticket_xlsx")  || "";
const T_PDF   = q.get("ticket_pdf")   || ""; // ç›´æ¥ pdf ãƒã‚±ãƒƒãƒˆ
const T_WORD  = q.get("ticket_word")  || ""; // ç›´æ¥ word ãƒã‚±ãƒƒãƒˆ
const T_MSG   = q.get("ticket_msg")   || "";
const TICKET_SINGLE = q.get("ticket") || ""; // å˜ä¸€ãƒã‚±ãƒƒãƒˆï¼ˆemlæƒ³å®šãªã©äº’æ›ï¼‰
const SINGLE_ATTACH = (q.get("single_attach") || "0") === "1"; // 1ã¤ã ã‘ä¿å­˜ã—ãŸã„ã¨ã
const ALL_ATTACH = (q.get("all_attachments") || "0") === "1";  // è¤‡æ•°ä¿å­˜ON
const KINDS = (q.get("kinds") || "").toLowerCase();              // "excel,pdf,word" ãªã©

// ãƒ™ãƒ¼ã‚¹ååˆæœŸå€¤
const EML_BASE_INIT  = (q.get("eml")   || "Report").trim();
const ATTACH_Q = (q.get("attach") ?? q.get("excel") ?? q.get("xlsx") ?? q.get("name_xlsx") ?? "").trim();
const XLSX_BASE_INIT = ATTACH_Q || "Attachment";

let HAS_ATTACH = false;
try {
  HAS_ATTACH = q.has("attach");
} catch (_) {
  HAS_ATTACH = false;
}
$("emlBase").value  = EML_BASE_INIT;
$("xlsxBase").value = XLSX_BASE_INIT;

// ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
const EP_PEEK               = "/tickets/peek";
const EP_UPLOAD_ORG         = "/api/upload";
const EP_LIST_FOLDERS       = "/api/drive/folders";
const EP_CREATE_FOLDER      = "/api/drive/create-folder";
const EP_CREATE_FOLDER_ALT  = "/api/drive/createFolder";
const EP_DELETE_FOLDER      = "/api/drive/delete-folder";
const EP_MSG_TO_ATTACH_TIDS = "/api/msg-to-attachment-tickets"; // æ–°APIï¼ˆçµ±ä¸€ï¼‰

// === upload-from-urlï¼ˆGitHub Raw ãªã©ï¼‰===
const EP_UPLOAD_FROM_URL  = "/api/upload-from-url";
const GITHUB_RAW_URL   = "https://github.com/miyasaka-t/macros/raw/refs/heads/main/runmacro_onedrive.vbs";
const GITHUB_SAVE_NAME = "runmacro_onedrive.vbs";

// åˆæœŸãƒ’ãƒ³ãƒˆ
(function initHints(){
  $("nm_eml_hint").textContent  = "ä¿å­˜æ™‚ã¯ã€Œ" + $("emlBase").value + ".emlã€ã‚’å¼·åˆ¶ä»˜ä¸";
  $("nm_xlsx_hint").textContent = "ä¿å­˜æ™‚ã¯ã€Œ" + $("xlsxBase").value + " + æ·»ä»˜ã®æ‹¡å¼µå­ã€ã‚’å¼·åˆ¶ä»˜ä¸";
})();

// æ·»ä»˜UIã®å‡ºã—åˆ†ã‘ï¼ˆattach= ãŒç„¡ã„ã¨ãã¯éè¡¨ç¤ºï¼‰
(function toggleAttachUI(){
  try{
    const col = document.getElementById("xlsxBase")?.closest(".col");
    if (col) col.style.display = (HAS_ATTACH ? "" : "none");
  }catch(e){ /* no-op */ }
})();
// ===== ãƒ•ã‚©ãƒ«ãƒ€æ¤œç´¢ï¼ˆCtrl+Fé¢¨ï¼‰ =====
let lastFolders = [];
let filterWord = "";

const searchBar = $("pickerSearchBar");
const searchInput = $("folderSearch");
const btnSearchToggle = $("btnSearchToggle");
const btnSearchClear  = $("btnSearchClear");

function toggleSearchBar(show){
  if (typeof show === "boolean") {
    searchBar.classList.toggle("show", show);
  } else {
    searchBar.classList.toggle("show");
  }
  if (searchBar.classList.contains("show")) {
    setTimeout(()=>searchInput.focus(), 0);
  } else {
    filterWord = "";
    searchInput.value = "";
    renderList(lastFolders || []);
  }
}

function escHtml(s){
  return (s || "").replace(/[&<>"']/g, function(m){
    return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]);
  });
}

function highlight(text, q){
  if (!q) return escHtml(text);
  try{
    const esc = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const re = new RegExp(esc, "ig");
    return escHtml(text).replace(re, (m)=>`<mark>${escHtml(m)}</mark>`);
  }catch(e){
    return escHtml(text);
  }
}

document.addEventListener("keydown", (ev)=>{
  if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === "f") {
    ev.preventDefault();
    toggleSearchBar(true);
  } else if (ev.key === "Escape" && searchBar.classList.contains("show")) {
    ev.preventDefault();
    toggleSearchBar(false);
  }
});
btnSearchToggle.onclick = ()=> toggleSearchBar();
btnSearchClear.onclick  = ()=> { searchInput.value=""; filterWord=""; renderList(lastFolders||[]); searchInput.focus(); };
let _searchTimer = null;
searchInput.addEventListener("input", ()=>{
  filterWord = searchInput.value.trim();
  clearTimeout(_searchTimer);
  _searchTimer = setTimeout(()=> renderList(lastFolders||[]), 100);
});
searchInput.addEventListener("keydown", (ev)=>{
  if (ev.key === "Enter") {
    ev.preventDefault();
    const first = document.querySelector("#list .tr .rowbox");
    if (first) first.click();
  } else if (ev.key === "Escape") {
    ev.preventDefault();
    toggleSearchBar(false);
  }
});

// ===== ãƒ‘ãƒ³ããš & ãƒ‘ã‚¹æç”» =====
function renderCurrentPath(){
  const names = breadcrumb.map(c=>c.name);
  const joined = names.join("/");
  const path = (joined.startsWith("/") ? joined : ("/" + joined.replace(/^ãƒ«ãƒ¼ãƒˆ\/?/, ""))).replace(/\/+/g,"/");
  $("currentPath").textContent = path === "/ãƒ«ãƒ¼ãƒˆ" ? "/" : ("/" + breadcrumb.slice(1).map(c=>c.name).join("/"));
}
function renderBreadcrumb(){
  const btnH=document.getElementById("btnHome"); if(btnH){ btnH.disabled = (!currentId || currentId==="root"); }
  const el = $("crumbs");
  el.innerHTML = "";
  breadcrumb.forEach((c,idx)=>{
    const s=document.createElement("span");
    s.className="crumb";
    s.textContent = c.name;
    s.onclick = ()=>{
      if(idx < breadcrumb.length-1){
        breadcrumb = breadcrumb.slice(0, idx+1);
        isNavigating = true; isLoading = true; updateSaveState(); loadFolder(breadcrumb[breadcrumb.length-1].id, false, "crumb");
      }
    };
    el.appendChild(s);
  });
}

// ===== ãƒ•ã‚©ãƒ«ãƒ€ãƒ”ãƒƒã‚«ãƒ¼ =====
let pickedFolderId=null,pickedFolderName=null,currentId="root",historyStack=[],breadcrumb=[{id:"root",name:"ãƒ«ãƒ¼ãƒˆ"}];
let selectedRowEl = null;
let isLoading = false;
let isNavigating = false;

function openPicker(){
  pickedFolderId=null; pickedFolderName=null;
  isNavigating = true; isLoading = true; updateSaveState();
  $("picker").style.display="flex"; setPickedHint();
  historyStack=[]; breadcrumb=[{id:"root",name:"ãƒ«ãƒ¼ãƒˆ"}];
  renderBreadcrumb(); renderCurrentPath();
  loadFolder(FIXED_START, false, "open");
}
function closePicker(){ $("picker").style.display="none"; }

async function loadFolder(id,pushHistory=true,from="enter"){
  isLoading = true; isNavigating = true; updateSaveState();
  $("list").innerHTML="";
  selectedRowEl = null;
  if(from!=="reload"){ filterWord=""; const fs=$("folderSearch"); if(fs) fs.value=""; }

  try{
    const r=await fetch(EP_LIST_FOLDERS+"?parentId="+encodeURIComponent(id||"root"));
    const j=await r.json();
    if(!r.ok) throw new Error(j.error||r.statusText);
    if(pushHistory&&currentId&&from!=="back") historyStack.push(currentId);
    currentId=id||"root"; renderBreadcrumb(); renderCurrentPath(); lastFolders = j.folders || [];
    renderList(lastFolders);
    renderCurrentPath();
    pickedFolderId = null; pickedFolderName = null; setPickedHint();
    isLoading = false; isNavigating = false; updateSaveState();
  }catch(e){ log("âŒ folder load: "+e.message); isLoading = false; isNavigating = false; updateSaveState(); setPickedHint(); }
}
  
function renderList(folders){
  const list=$("list");
  let arr = folders || [];
  if (filterWord) {
    const q = filterWord.toLowerCase();
    arr = arr.filter(x => (x.name||"").toLowerCase().includes(q));
  }
  if(!arr.length){ list.innerHTML="<div style='padding:10px'>ï¼ˆè©²å½“ãªã—ï¼‰</div>"; return; }
  list.innerHTML="";
  arr.forEach(f=>{
    const row=document.createElement("div"); row.className="tr";
    const left=document.createElement("div"); left.className="rowbox name"; left.innerHTML="ğŸ“ " + highlight(f.name, filterWord);
    left.onclick=()=>{
      if(selectedRowEl) selectedRowEl.classList.remove("selected");
      left.classList.add("selected");
      selectedRowEl = left;
      pickedFolderId = f.id;
      pickedFolderName = f.name;
      isNavigating = false; updateSaveState(); setPickedHint(); $("pickerSave").disabled=false;
      renderCurrentPath();
    };
    left.ondblclick = () => enterFolder(f.id,f.name);

    const right=document.createElement("div"); right.className="act";
    const bOpen=document.createElement("button"); bOpen.textContent="é–‹ã"; bOpen.onclick=()=>enterFolder(f.id,f.name);
    const bDel=document.createElement("button"); bDel.textContent="å‰Šé™¤"; bDel.onclick=()=>deleteFolder(f.id,f.name);
    right.appendChild(bOpen); right.appendChild(bDel);

    row.appendChild(left); row.appendChild(right);
    list.appendChild(row);
  });
}
function enterFolder(id,name){ breadcrumb.push({id,name}); renderBreadcrumb(); renderCurrentPath(); loadFolder(id,true,"enter"); }

async function deleteFolder(id,name){
  if(!confirm(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`)) return;
  try{
    const r = await fetch(EP_DELETE_FOLDER, { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({ id }) });
    const j = await r.json().catch(()=>({}));
    if(!r.ok || j.ok !== true){ throw new Error((j && (j.detail||j.error)) || r.statusText); }
    log(`ğŸ—‘ï¸ å‰Šé™¤: ${name}`);
    await loadFolder(currentId,false,"delete");
  }catch(e){
    alert("å‰Šé™¤å¤±æ•—: " + e.message);
  }
}

$("btnBack").onclick=()=>{ if(!historyStack.length) return; const prev=historyStack.pop(); isNavigating = true; isLoading = true; updateSaveState(); loadFolder(prev,false,"back"); };
$("btnUp").onclick=()=>{ if(breadcrumb.length<=1) return; breadcrumb.pop(); isNavigating = true; isLoading = true; updateSaveState(); loadFolder(breadcrumb[breadcrumb.length-1].id,false,"up"); };
$("btnReload").onclick=()=>isNavigating = true; isLoading = true; updateSaveState(); loadFolder(currentId,false,"reload");

// æ–°è¦ãƒ•ã‚©ãƒ«ãƒ€
async function createFolderCall(url,parentId,name){
  const body={parentId:parentId||"root",name:(name||"").trim(),conflictBehavior:"rename"};
  const r=await fetch(url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(body)});
  const txt=await r.text(); let j; try{ j=JSON.parse(txt);}catch{ j={raw:txt}; }
  log(`POST ${url} â†’ ${r.status}
req=${JSON.stringify(body)}
res=${txt.substring(0,200)}`);
  return { ok:r.ok, status:r.status, json:j };
}
$("btnNewFolder").onclick=async()=>{
  const base=prompt("æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€å?",""); if(!base) return; const name=base.trim(); if(!name) return;
  const pid=(!currentId||currentId==="undefined"||currentId==="null")?"root":currentId;
  let res=await createFolderCall(EP_CREATE_FOLDER,pid,name);
  if(res.status===404){ res=await createFolderCall(EP_CREATE_FOLDER_ALT,pid,name); }
  if(res.ok){ log(`ğŸ“ ä½œæˆ: ${res.json.name}`); isNavigating = true; isLoading = true; updateSaveState(); await loadFolder(pid,false,"created"); }
  else { alert("ä½œæˆå¤±æ•—: "+res.status); }
};

$("pickerCancel").onclick=closePicker;

// ===== APIãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
async function uploadOne(endpoint,ticket,nameOverride){
  const fd=new FormData();
  fd.append("ticket",ticket);
  fd.append("folderId",pickedFolderId || currentId || "root");
  if(nameOverride) fd.append("fileName",nameOverride);
  const r=await fetch(endpoint,{method:"POST",body:fd});
  const j=await r.json().catch(()=>({}));
  return { ok:r.ok, status:r.status, body:j };
}

// .msg/.eml â†’ æ·»ä»˜ï¼ˆexcel/pdf/wordï¼‰è¤‡æ•°ãƒã‚±ãƒƒãƒˆåŒ–ï¼ˆæ—§APIç½®æ›ï¼‰
async function createAttachmentTicketsFromMsg(msgTicket, baseName, kinds, single){
  const payload = { ticket: msgTicket };
  if (baseName && baseName.trim()) payload.baseName = baseName.trim();
  if (kinds && kinds.trim()) payload.kinds = kinds.trim();
  if (single === true) { payload.limit = 1; payload.pick = "first"; }
  const r = await fetch(EP_MSG_TO_ATTACH_TIDS, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });
  const j = await r.json().catch(()=>({}));
  if (!r.ok || !j.ok) throw new Error("msg-to-attachment-tickets failed: "+JSON.stringify(j));
  return j.tickets || [];
}

// URLã‹ã‚‰ç›´æ¥ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆGitHub Rawãªã©ï¼‰
async function uploadFromUrl(url, folderId, fileName){
  const body = { url, folderId, fileName };
  const r = await fetch(EP_UPLOAD_FROM_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });
  const j = await r.json().catch(()=>({}));
  return { ok:r.ok, status:r.status, body:j };
}

// ===== ã™ã¹ã¦ä¿å­˜ï¼ˆEML / MSG / æ·»ä»˜ï¼‰ + æ¡ä»¶ä»˜ã GitHubä¿å­˜ =====
async function doUpload(){
  const targetFolderId = pickedFolderId || currentId || "root";
  const targetFolderName = pickedFolderName || (breadcrumb[breadcrumb.length-1] && breadcrumb[breadcrumb.length-1].name) || "/";
  setPickedHint();

  const emlBase  = ($("emlBase").value  || "Report").trim();
  const attachBase = ($("xlsxBase").value || "Attachment").trim();
  const emlName = emlBase.toLowerCase().endsWith(".eml") ? emlBase : (emlBase + ".eml");

  const want_eml  = Boolean(T_EML || TICKET_SINGLE);
  const want_msg  = Boolean(T_MSG);
  const want_direct = Boolean(T_XLSX || T_PDF || T_WORD);

  if(!want_eml && !want_msg && !want_direct){
    alert("ä¿å­˜ã™ã‚‹ãƒã‚±ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆticket_eml / ticket_msg / ticket_xlsx / ticket_pdf / ticket_word / ticket ã®ã„ãšã‚Œã‹ãŒå¿…è¦ï¼‰");
    return;
  }

  try {
    // 0) ã¾ãš .msg ã®æ·»ä»˜æŠ½å‡ºï¼ˆéæ¶ˆè²»ï¼‰â†’ Excel å«æœ‰ãƒã‚§ãƒƒã‚¯
    let extractedTickets = [];
    let hasExcelInMsg = false;
    if (want_msg && HAS_ATTACH) {
      try{
        const single = SINGLE_ATTACH && !ALL_ATTACH; // å˜ä¸€æŒ‡å®šæ™‚
        extractedTickets = await createAttachmentTicketsFromMsg(T_MSG, attachBase, KINDS, single);
        hasExcelInMsg = extractedTickets.some(t => (t.kind||"") === "excel");
        if (!extractedTickets.length) {
          log("â„¹ï¸ æ·»ä»˜ãªã—ï¼ˆæƒ³å®šå†…ï¼‰");
        } else {
          if (single) log("â†’ å˜ä¸€æ·»ä»˜ãƒ¢ãƒ¼ãƒ‰ pick=first / limit=1");
          if (KINDS)  log("â†’ kinds="+KINDS);
          log("æŠ½å‡ºä»¶æ•°: "+extractedTickets.length+ (hasExcelInMsg?"ï¼ˆExcelå«ã‚€ï¼‰":""));
        }
      }catch(e){
        try{
        const m = String(e && e.message || "");
        if (m.includes("no_allowed_attachment_found")) {
          log("â„¹ï¸ æ·»ä»˜ãªã—ï¼ˆæƒ³å®šå†…ï¼‰");
        } else {
          log("âš ï¸ msg-to-attachment-tickets ã‚¨ãƒ©ãƒ¼: " + m);
        }
      }catch(_){ log("âš ï¸ msg-to-attachment-tickets ã‚¨ãƒ©ãƒ¼ï¼ˆè§£æå¤±æ•—ï¼‰"); }
}
    }

    // 1) .eml ä¿å­˜
    if (want_eml && !(typeof EML_ALREADY_UPLOADED !== 'undefined' && EML_ALREADY_UPLOADED)) {
      const t = T_EML || TICKET_SINGLE;
      log("â†’ eml upload as: " + emlName);
      const r = await uploadOne(EP_UPLOAD_ORG, t, emlName);
      log(r.ok ? "âœ… AIä½œæˆæœ¬æ–‡ä¿å­˜æˆåŠŸ" : "âŒ eml " + JSON.stringify(r.body));
    }

    // 2) .msg åŸæ–‡ä¿å­˜ï¼ˆã“ã“ã§ msg ãƒã‚±ãƒƒãƒˆæ¶ˆè²»ï¼‰
    if (want_msg) {
      log("â†’ msg upload (original name)");
      const r = await uploadOne(EP_UPLOAD_ORG, T_MSG, null);
      log(r.ok ? "âœ… BPã•ã‚“ã‹ã‚‰ã®ãƒ¡ãƒ¼ãƒ«ä¿å­˜æˆåŠŸ" : "âŒ msg " + JSON.stringify(r.body));
    }


    // 3) ç›´æ¥æ¥ãŸãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆxlsx/pdf/wordï¼‰ãƒã‚±ãƒƒãƒˆï¼ˆäº’æ›ï¼‰
    const directTickets = [
      { tid: T_XLSX, kind: "excel" },
      { tid: T_PDF,  kind: "pdf"   },
      { tid: T_WORD, kind: "word"  },
    ].filter(x => !!x.tid);

    for (const d of directTickets) {
      try{
        const peek = await fetch(EP_PEEK+"?ticket="+encodeURIComponent(d.tid)).then(r=>r.json());
        const orig = (peek && peek.fileName) || "attachment";
        const ext  = (orig.lastIndexOf(".")>=0) ? orig.slice(orig.lastIndexOf(".")) :
                      (d.kind==="excel"?".xlsx": d.kind==="pdf"?".pdf": ".docx");
        const final = (attachBase || "Attachment") + ext;
        log(`â†’ direct ${d.kind} upload as: ${final}`);
        const r = await uploadOne(EP_UPLOAD_ORG, d.tid, final);
        log(r.ok ? `âœ… æ·»ä»˜ï¼ˆæ—¢å­˜${d.kind}ï¼‰ä¿å­˜æˆåŠŸ` : `âŒ ${d.kind} ` + JSON.stringify(r.body));
      }catch(e){
        log(`âš ï¸ ${d.kind} direct upload error: `+e.message);
      }
    }

    // 4) å…ˆã«æŠ½å‡ºã—ã¦ãŠã„ãŸæ·»ä»˜ãƒã‚±ãƒƒãƒˆã‚’ä¿å­˜
    if (extractedTickets && extractedTickets.length){
      for (const t of extractedTickets){
        const nm = t.fileName || "attachment";
        log("â†’ attach upload: "+ nm + (t.kind?` (${t.kind})`:''));
        const r = await uploadOne(EP_UPLOAD_ORG, t.ticket, nm);
        log(r.ok ? "âœ… æ·»ä»˜ä¿å­˜æˆåŠŸ: "+nm : "âŒ attach "+nm+" "+JSON.stringify(r.body));
      }
    }

    // 5) æ¡ä»¶ä»˜ã GitHub VBS ä¿å­˜ï¼š.msg ã®æ·»ä»˜ã« Excel ãŒå«ã¾ã‚Œã¦ã„ãŸå ´åˆã®ã¿
    const shouldSaveVbs = (hasExcelInMsg || Boolean(T_XLSX));
    if (shouldSaveVbs) {
      try{
        log("â†’ æ¡ä»¶ä¸€è‡´ï¼ˆExcelæ·»ä»˜ã‚ã‚Šï¼‰: upload-from-url " + GITHUB_RAW_URL);
        const r4 = await uploadFromUrl(GITHUB_RAW_URL, targetFolderId, GITHUB_SAVE_NAME);
        if (r4.ok && r4.body && r4.body.ok) {
          log("âœ… GitHubãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜æˆåŠŸ: " + (r4.body.name || GITHUB_SAVE_NAME));
        } else {
          log("âš ï¸ GitHubä¿å­˜å¤±æ•—: " + JSON.stringify(r4.body));
        }
      }catch(e){
        log("âš ï¸ upload-from-url ã‚¨ãƒ©ãƒ¼: " + e.message);
      }
    } else {
      log("ï¼ˆVBSä¿å­˜æ¡ä»¶ä¸ä¸€è‡´: ExcelãŒå­˜åœ¨ã—ãªã„ï¼‰");
    }

    setPickedHint();
  } catch(e){
    log("âŒ "+ e.message);
  }
}

// ãƒ”ãƒƒã‚«ãƒ¼æ“ä½œ
$("openPicker").onclick=openPicker;
$("pickerSave").onclick=async ()=>{
  closePicker();
  await doUpload();
};

function goToRoot(){
  try{
    historyStack = [];
    breadcrumb = [{id:"root", name:"ãƒ«ãƒ¼ãƒˆ"}];
    isNavigating = true; isLoading = true; updateSaveState(); loadFolder("root", true, "home");
  }catch(e){ log("âŒ goToRoot: " + e.message); }
}
try{ document.getElementById("btnHome").onclick = goToRoot; }catch(e){}

async function uploadDirectTicket(endpointPeek, endpointUpload, ticketId, attachBase, kind) {
  const peek = await fetch(endpointPeek + "?ticket=" + encodeURIComponent(ticketId)).then(r => r.json());
  const orig = (peek && peek.fileName) || "attachment";
  const dot = orig.lastIndexOf(".");
  let ext = dot >= 0 ? orig.slice(dot) : "";
  if (!ext) {
    if (kind === "excel") ext = ".xlsx";
    else if (kind === "pdf") ext = ".pdf";
    else if (kind === "word") ext = ".docx";
  }
  const final = (attachBase && attachBase.trim()) ? (attachBase.trim() + ext.toLowerCase()) : orig;
  const fd = new FormData();
  fd.append("ticket", ticketId);
  fd.append("fileName", final);
  const r = await fetch((window.EP_UPLOAD_ORG || "/api/upload"), { method: "POST", body: fd });
  try { return await r.json(); } catch { return { ok: false, status: r.status }; }
}


// === Added: process direct xlsx/pdf/word tickets based on query ===
(async () => {
  try {
    const url = new URL(window.location.href);
    const q = url.searchParams;
    const T_XLSX = q.get("ticket_xlsx") || "";
    const T_PDF  = q.get("ticket_pdf")  || "";
    const T_WORD = q.get("ticket_word") || "";
    const ATTACH = (q.get("attach") || "").trim();
    const attachBase = ATTACH || "Attachment";

    const jobs = [];
    if (T_XLSX) jobs.push(uploadDirectTicket((window.EP_PEEK || "/api/tickets/peek"), (window.EP_UPLOAD_ORG || "/api/upload"), T_XLSX, attachBase, "excel"));
    if (T_PDF)  jobs.push(uploadDirectTicket((window.EP_PEEK || "/api/tickets/peek"), (window.EP_UPLOAD_ORG || "/api/upload"), T_PDF,  attachBase, "pdf"));
    if (T_WORD) jobs.push(uploadDirectTicket((window.EP_PEEK || "/api/tickets/peek"), (window.EP_UPLOAD_ORG || "/api/upload"), T_WORD, attachBase, "word"));

    if (jobs.length) {
      const results = await Promise.all(jobs);
      console.log("Direct ticket uploads:", results);
    }
  } catch (e) {
    console.warn("direct tickets handling failed:", e);
  }
})();
</script>


<script>
// === B plan: show modal immediately, but keep list/breadcrumb hidden with loading skeleton & overlay ===
(function(){
  // Utilities for loading UI
  function showLoadingUI() {
    try {
      var overlay = document.getElementById("loadingOverlay");
      if (overlay) overlay.classList.add("show");
      var list = document.getElementById("list");
      if (list) {
        var rows = new Array(8).fill(0).map(function(){ return '<div class="skeleton-row"></div>'; }).join('');
        list.innerHTML = rows;
      }
    } catch(e) { /* no-op */ }
  }
  function hideLoadingUI() {
    try {
      var overlay = document.getElementById("loadingOverlay");
      if (overlay) overlay.classList.remove("show");
    } catch(e) { /* no-op */ }
  }

  // Keep a reference to original functions if they exist
  // Default initial folder ID (same as non-edit flow)
  try {
    if (typeof window.INIT_FOLDER_ID === 'undefined' || !window.INIT_FOLDER_ID) {
      window.INIT_FOLDER_ID = "01URYU5JOWFGM7H5QYZNBIIMMFCSQLV6BK";
    }
  } catch(e){}
  var _orig_openPicker = (typeof openPicker === "function") ? openPicker : null;
  var _orig_loadFolder = (typeof loadFolder === "function") ? loadFolder : null;
  var _orig_setPickedHint = (typeof setPickedHint === "function") ? setPickedHint : function(){};
  var _orig_renderBreadcrumb = (typeof renderBreadcrumb === "function") ? renderBreadcrumb : function(){};
  var _orig_renderCurrentPath = (typeof renderCurrentPath === "function") ? renderCurrentPath : function(){};
  var _orig_updateSaveState = (typeof updateSaveState === "function") ? updateSaveState : function(){};

  // Override setPickedHint to no-op while loading (avoid "ä¿å­˜å…ˆ: ãƒ«ãƒ¼ãƒˆ" flicker)
  window.setPickedHint = function(){
    try {
      if (typeof isLoading !== "undefined" && isLoading) return; // defer while loading
    } catch(e) {}
    return _orig_setPickedHint();
  };

  // Override openPicker: show modal immediately but don't call setPickedHint yet; show loading UI
  window.openPicker = function(){
    try {
      if (typeof pickedFolderId !== "undefined") { pickedFolderId = null; }
      if (typeof pickedFolderName !== "undefined") { pickedFolderName = null; }
      if (typeof isNavigating !== "undefined") { isNavigating = true; }
      if (typeof isLoading !== "undefined") { isLoading = true; }
      _orig_updateSaveState();
    } catch(e){}
    // show modal outer frame immediately
    try { document.getElementById("picker").style.display = "flex"; } catch(e){}
    showLoadingUI();
    // Reset history/breadcrumb to root silently (UI is hidden via CSS in this build)
    try {
      if (typeof historyStack !== "undefined") historyStack = [];
      if (typeof breadcrumb !== "undefined") breadcrumb = [{id:"root", name:"ãƒ«ãƒ¼ãƒˆ"}];
    } catch(e){}
    // Start loading initial folder (keep same initial ID as existing implementation if available)
    var initialId = "root";
    try {
      // Try to extract the initial folder ID from existing code by sniffing a known element/value if present
      // Fallback to a commonly used ID if defined on window.INIT_FOLDER_ID
      if (typeof INIT_FOLDER_ID !== "undefined" && INIT_FOLDER_ID) {
        initialId = INIT_FOLDER_ID;
      } else {
        // If currentId is meaningful, prefer it; else keep root (will be replaced soon anyway)
        if (typeof currentId !== "undefined" && currentId && currentId !== "root") initialId = currentId;
      }
    } catch(e){}
    // If the original openPicker had a hard-coded ID, we cannot detect reliably here; instead just call our loadFolder override below.
    window.loadFolder(initialId, false, "open");
  };

  // Override loadFolder: show skeleton during fetch; only after success, render list then setPickedHint
  window.loadFolder = async function(id, pushHistory, from){
    try {
      if (typeof isLoading !== "undefined") isLoading = true;
      if (typeof isNavigating !== "undefined") isNavigating = true;
      _orig_updateSaveState();
    } catch(e){}
    showLoadingUI();
    var ok = false, j = null, err = null;
    try {
      const url = (typeof EP_LIST_FOLDERS !== "undefined" ? EP_LIST_FOLDERS : "/api/drive/folders") + "?parentId=" + encodeURIComponent(id || "root");
      const r = await fetch(url);
      j = await r.json();
      if (!r.ok) throw new Error(j.error || r.statusText || "folder load failed");
      ok = true;
    } catch(e) {
      err = e;
    }
    try {
      if (ok) {
        // Update navigation state and render list only now
        if (pushHistory && typeof currentId !== "undefined" && currentId && from !== "back") {
          try { if (typeof historyStack !== "undefined") historyStack.push(currentId); } catch(e){}
        }
        if (typeof currentId !== "undefined") currentId = id || "root";
        if (typeof lastFolders !== "undefined") lastFolders = (j && j.folders) || [];
        if (typeof renderList === "function") renderList(lastFolders);
        if (typeof renderCurrentPath === "function") _orig_renderCurrentPath();
        if (typeof _orig_renderBreadcrumb === "function") _orig_renderBreadcrumb();  // update Home button state // breadcrumb/path UI may be hidden by CSS in this build
        if (typeof pickedFolderId !== "undefined") pickedFolderId = null;
        if (typeof pickedFolderName !== "undefined") pickedFolderName = null;
        // mark loading done before hint update
        if (typeof isLoading !== "undefined") isLoading = false;
        if (typeof isNavigating !== "undefined") isNavigating = false;
        hideLoadingUI();
        _orig_updateSaveState();
        _orig_setPickedHint();
      } else {
        // on error
        if (typeof console !== "undefined") console.warn("folder load error:", err && err.message);
        if (typeof isLoading !== "undefined") isLoading = false;
        if (typeof isNavigating !== "undefined") isNavigating = false;
        hideLoadingUI();
        _orig_updateSaveState();
        _orig_setPickedHint();
      }
    } catch(e) {
      // fail-safe
      if (typeof isLoading !== "undefined") isLoading = false;
      if (typeof isNavigating !== "undefined") isNavigating = false;
      hideLoadingUI();
      _orig_updateSaveState();
      _orig_setPickedHint();
    }
  };
  // Wire picker toolbar controls (Back / Up / Home / Reload)
  (function wirePickerToolbar(){
    try{
      var back = document.getElementById('btnBack');
      if (back && !back.__wired) {
        back.__wired = true;
        back.onclick = function(){
          try {
            var prev = (typeof historyStack !== 'undefined' && historyStack.length) ? historyStack.pop() : null;
            var target = prev || 'root';
            if (typeof loadFolder === 'function') loadFolder(target, false, 'back');
          } catch(e){}
        };
      }
      var up = document.getElementById('btnUp');
      if (up && !up.__wired) {
        up.__wired = true;
        up.onclick = function(){
          try {
            if (typeof breadcrumb !== 'undefined' && breadcrumb.length > 1) {
              breadcrumb.pop();
              var parentId = breadcrumb[breadcrumb.length-1].id;
              if (typeof loadFolder === 'function') loadFolder(parentId, true, 'up');
            }
          } catch(e){}
        };
      }
      var home = document.getElementById('btnHome');
      if (home && !home.__wired) {
        home.__wired = true;
        home.onclick = function(){
          try {
            if (typeof historyStack !== 'undefined') historyStack = [];
            if (typeof breadcrumb !== 'undefined') breadcrumb = [{id:'root', name:'ãƒ«ãƒ¼ãƒˆ'}];
            if (typeof loadFolder === 'function') loadFolder('root', false, 'home');
          } catch(e){}
        };
      }
      var reloadBtn = document.getElementById('btnReload');
      if (reloadBtn && !reloadBtn.__wired) {
        reloadBtn.__wired = true;
        reloadBtn.onclick = function(){
          try { if (typeof loadFolder === 'function') loadFolder((typeof currentId!=='undefined' && currentId) ? currentId : 'root', false, 'reload'); } catch(e){}
        };
      }
    }catch(e){}
  })();

})();
</script>

<!-- ãƒ¡ãƒ¼ãƒ«ç·¨é›†ï¼ˆ.emlï¼‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
<section id="mailEditor" style="display:none;margin-top:16px;border:1px solid #ddd;padding:12px;border-radius:8px;">
  <div style="display:flex;align-items:center;gap:8px;">
    <h3 style="margin:0;">âœ‰ï¸ ãƒ¡ãƒ¼ãƒ«ç·¨é›†ï¼ˆ.emlï¼‰</h3>
    <span id="mailEditorStatus" style="font-size:12px;color:#666"></span>
  </div>
  <div style="margin-top:8px;">
    <label>ä»¶å</label>
    <input id="mailSubject" type="text" style="width:100%;padding:6px;" placeholder="ä»¶å" />
  </div>
  <div style="margin-top:8px;">
    <div style="display:flex;gap:8px;margin-bottom:6px;">
      <button type="button" id="tabHtml">HTML</button>
      <button type="button" id="tabText">ãƒ†ã‚­ã‚¹ãƒˆ</button>
    </div>
    <div id="htmlPane" contenteditable="true" style="border:1px solid #ccc;min-height:160px;padding:8px;overflow:auto;"></div>
    <textarea id="textPane" style="display:none;width:100%;min-height:160px;padding:8px;"></textarea>
  </div>
  <div style="margin-top:10px;display:flex;gap:8px;">
    <button type="button" id="btnComposeSave">ç·¨é›†å†…å®¹ã§ä¿å­˜</button>
  </div>
</section>

<script>
(function(){
  const qs = new URLSearchParams(location.search);
  const T_EML = qs.get('ticket_eml') || qs.get('ticket');
  const elEditor = document.getElementById('mailEditor');
  const elStatus = document.getElementById('mailEditorStatus');
  const elSubj   = document.getElementById('mailSubject');
  const elHtml   = document.getElementById('htmlPane');
  const elText   = document.getElementById('textPane');
  const tabHtml  = document.getElementById('tabHtml');
  const tabText  = document.getElementById('tabText');
  const btnSave  = document.getElementById('btnComposeSave');

  function showHTML(){ elHtml.style.display='block'; elText.style.display='none'; }
  function showText(){ elHtml.style.display='none';  elText.style.display='block'; }
  tabHtml?.addEventListener('click', showHTML);
  tabText?.addEventListener('click', showText);

  async function loadPreview(){
    if(!T_EML) return;
    try{
      elEditor.style.display = '';
      elStatus.textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
      const r = await fetch(`/api/mail/preview-from-ticket?ticket=${encodeURIComponent(T_EML)}`);
      const j = await r.json();
      if(!j.ok){ throw new Error(j.error||'preview failed'); }
      elSubj.value = j.subject || '';
      elHtml.innerHTML = (j.body_html || '').trim();
      elText.value    = (j.body_text || '').trim();
      elStatus.textContent = 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼OK';
    }catch(e){
      console.error(e);
      elStatus.textContent = 'èª­ã¿è¾¼ã¿å¤±æ•—';
    }
  }

  async function composeAndUpload(){
    try{
      elStatus.textContent = 'å†çµ„ã¿ç«‹ã¦ä¸­...';
      const payload = {
        ticket: T_EML,
        subject: elSubj.value || '',
        body_html: elHtml.innerHTML || '',
        body_text: elText.value || '',
        keep_attachments: true,
        regenerate_date: true,
        suggestedBaseName: (window.inputBaseName?.value || '').trim() || undefined
      };
      const r = await fetch('/api/mail/compose-from-ticket', {
        method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload)
      });
      const j = await r.json();
      if(!j.ok){ throw new Error(j.error||'compose failed'); }
      const composedTicket = j.ticket_eml;
      elStatus.textContent = 'å†çµ„ã¿ç«‹ã¦OK â†’ ä¿å­˜ä¸­...';

      const fd = new FormData();
      fd.append('ticket', composedTicket);
      fd.append('folderId', window.PICKED_FOLDER_ID || 'root');
      if(j.suggestedFileName){ fd.append('fileName', j.suggestedFileName); }
      const r2 = await fetch('/api/upload', { method:'POST', body: fd });
      const j2 = await r2.json();
      if(!j2.ok){ throw new Error(j2.error||'upload failed'); }
      elStatus.textContent = 'ä¿å­˜å®Œäº†';
      if(window.onUploadSuccess){ window.onUploadSuccess(j2); }
    }catch(e){
      console.error(e);
      elStatus.textContent = 'ä¿å­˜å¤±æ•—';
      alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: '+e.message);
    }
  }

  document.getElementById('btnComposeSave')?.addEventListener('click', composeAndUpload);
  loadPreview();
})();
</script>

<!-- eml-final-patch version 1762397407 -->
<script>
(function(){
  if (window.__emlFinalPatch__) return;
  window.__emlFinalPatch__ = "1762397407";

  // Visible version mark
  try {
    var v = document.createElement('div');
    v.style.cssText = 'margin-top:6px;font-size:11px;color:#666;';
    v.textContent = 'EML Final Patch: 1762397407';
    (document.body || document.documentElement).appendChild(v);
  } catch(_e) { }

  var qs = new URLSearchParams(location.search);
  var T_EML = qs.get('ticket_eml') || qs.get('ticket') || '';

  var elStatus = document.getElementById('mailEditorStatus');
  var elSubj   = document.getElementById('mailSubject');
  var elHtml   = document.getElementById('htmlPane');
  var elText   = document.getElementById('textPane');
  var btnSave  = document.getElementById('btnComposeSave');

  function setStatus(t){ if (elStatus) elStatus.textContent = t; }

  // Define composeAndUpload in a safe, non-async way
  window.composeAndUpload = function(){
    try {
      setStatus('å†çµ„ã¿ç«‹ã¦ä¸­...');
      var payload = {
        ticket: T_EML,
        subject: elSubj ? (elSubj.value || '') : '',
        body_html: elHtml ? (elHtml.innerHTML || '') : '',
        body_text: elText ? (elText.value || '') : '',
        keep_attachments: true,
        regenerate_date: true,
        suggestedBaseName: (window.inputBaseName && window.inputBaseName.value ? window.inputBaseName.value.trim() : undefined)
      };
      fetch('/api/mail/compose-from-ticket', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      .then(function(r){ return r.json(); })
      .then(function(j){
        if(!j || j.ok !== true) throw new Error((j && j.error) || 'compose failed');
        // Stash edited ticket for later upload
        window.EDITED_TICKET_EML = j.ticket_eml;
        window.EDITED_FILE_NAME  = j.suggestedFileName || '';
        setStatus('ç·¨é›†ç‰ˆã®ä¿å­˜å…ˆã‚’é¸æŠã—ã¦ãã ã•ã„...');
        // Open existing picker (same UX as the original button)
        if (typeof window.openPicker === 'function') {
          window.window.INIT_FOLDER_ID = FIXED_START;
  openPicker();
        } else {
          // Try click a visible button with the original/new label
          var btns = Array.from(document.querySelectorAll('button, [role="button"], .btn, .button'));
          var cand = btns.find(function(b){ var t=(b.textContent||''); return t.indexOf('ç·¨é›†ã›ãšã«ä¿å­˜')>=0 || t.indexOf('ä¿å­˜å…ˆã‚’é¸ã¶')>=0; });
          if (cand) try { cand.click(); } catch(_e){}
        }
      })
      .catch(function(e){
        console.error(e);
        setStatus('ä¿å­˜å¤±æ•—');
        alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
      });
    } catch(e) {
      console.error(e);
      setStatus('ä¿å­˜å¤±æ•—');
      alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
    }
  };

  // Hook button if present
  if (btnSave) {
    try { btnSave.removeEventListener('click', window.composeAndUpload); } catch(_e){}
    btnSave.addEventListener('click', window.composeAndUpload);
  }

  // Wrap doUpload so that if an edited ticket exists, we upload it and return early.
  (function wrapDoUpload(){
    if (window.__orig_doUpload__) return; // already wrapped
    if (typeof window.doUpload !== 'function') return;
    window.__orig_doUpload__ = window.doUpload;
    window.doUpload = function(){
      // If we have an edited EML, upload it first, then continue with the normal pipeline
      if (window.EDITED_TICKET_EML) {
        var emlBaseEl = document.getElementById('emlBase');
        var emlBase = emlBaseEl ? (emlBaseEl.value||'Report').trim() : 'Report';
        var editedName = (emlBase.toLowerCase().endsWith('.eml') ? emlBase : (emlBase + '.eml')); // Pattern B: always use UI base name
        return Promise.resolve()
          .then(function(){ return uploadOne(EP_UPLOAD_ORG, window.EDITED_TICKET_EML, editedName); })
          .then(function(r){
            if (typeof log === 'function') log(r.ok ? "âœ… ç·¨é›†å¾Œæœ¬æ–‡ä¿å­˜æˆåŠŸ" : ("âŒ ç·¨é›†å¾Œ eml " + JSON.stringify(r.body)));
            // Set a guard so original doUpload won't save EML again
            window.EML_ALREADY_UPLOADED = true;
            // Clear edited variables to avoid reuse
            window.EDITED_TICKET_EML = null;
            window.EDITED_FILE_NAME = null;
          })
          .then(()=>{
            try{ if (typeof setPickedHint === 'function') setPickedHint(); }catch(_e){}
            // Continue with the original pipeline (msg, attachments, VBS, etc.)
            return window.__orig_doUpload__.apply(this, arguments);
          })
          .finally(function(){
            // Remove guard after run
            try{ window.EML_ALREADY_UPLOADED = false; }catch(_e){}
          })
          .catch(function(e){
            console.error(e);
            if (typeof log === 'function') log("âŒ ç·¨é›†å¾Œ eml ä¿å­˜ã‚¨ãƒ©ãƒ¼: " + (e && e.message));
            throw e;
          });
      }
      // No edited ticket: normal behavior
      return window.__orig_doUpload__.apply(this, arguments);
    };
  })();  // ---------- (2) Picker initial folder: align "ç·¨é›†å†…å®¹ã§ä¿å­˜" with normal flow ----------
  // Remember last folder id when possible
  window.DEFAULT_START_FOLDER = window.DEFAULT_START_FOLDER || null;

  function _getCurrentFolderId(){
    try {
      if (window.PICKED_FOLDER_ID && String(window.PICKED_FOLDER_ID).trim()) return String(window.PICKED_FOLDER_ID).trim();
      if (window.currentId && String(window.currentId).trim()) return String(window.currentId).trim();
    } catch(_e) {}
    return null;
  }

  (function rememberOnSave(){
    try {
      var btn = document.getElementById('pickerSave');
      if (btn && !btn.__emlPatchBound) {
        btn.__emlPatchBound = true;
        var orig = btn.onclick;
        btn.onclick = function(ev){
          try {
            var fid = _getCurrentFolderId() || 'root';
            window.DEFAULT_START_FOLDER = fid;
          } catch(_e) {}
          if (typeof orig === 'function') return orig.call(this, ev);
        };
      }
    } catch(_e) {}
  })();

  function _composeAndOpenPicker(){
    try {
      var elStatus = document.getElementById('mailEditorStatus');
      var elSubj   = document.getElementById('mailSubject');
      var elHtml   = document.getElementById('htmlPane');
      var elText   = document.getElementById('textPane');
      var qs = new URLSearchParams(location.search);
      var T_EML = qs.get('ticket_eml') || qs.get('ticket');

      if (elStatus) elStatus.textContent = 'å†çµ„ã¿ç«‹ã¦ä¸­...';

      var payload = {
        ticket: T_EML || '',
        subject: (elSubj && elSubj.value) ? elSubj.value : '',
        body_html: (elHtml && elHtml.innerHTML) ? elHtml.innerHTML : '',
        body_text: (elText && elText.value) ? elText.value : '',
        keep_attachments: true,
        regenerate_date: true,
        suggestedBaseName: (window.inputBaseName && window.inputBaseName.value ? window.inputBaseName.value.replace(/^\s+|\s+$/g,'') : undefined)
      };
      fetch('/api/mail/compose-from-ticket', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      .then(function(r){ return r.json(); })
      .then(function(j){
        if (!j || j.ok !== true) throw new Error((j && j.error) || 'compose failed');
        window.EDITED_TICKET_EML = j.ticket_eml;
        window.EDITED_FILE_NAME  = j.suggestedFileName || '';
        if (elStatus) elStatus.textContent = 'ç·¨é›†ç‰ˆã®ä¿å­˜å…ˆã‚’é¸æŠã—ã¦ãã ã•ã„...';

        try {
          var last = window.DEFAULT_START_FOLDER || _getCurrentFolderId() || 'root';
          window.INIT_FOLDER_ID = last;
        } catch(_e) {}

        if (typeof window.openPicker === 'function') {
          window.window.INIT_FOLDER_ID = FIXED_START;
  openPicker();
        } else {
          var btns = document.querySelectorAll('button, [role="button"], .btn, .button');
          for (var i=0;i<btns.length;i++) {
            var t = (btns[i].textContent||'');
            if (t.indexOf('ç·¨é›†ã›ãšã«ä¿å­˜')>=0 || t.indexOf('ä¿å­˜å…ˆã‚’é¸ã¶')>=0) { try{ btns[i].click(); }catch(_e){} break; }
          }
        }

        setTimeout(function(){
          try {
            var target = window.DEFAULT_START_FOLDER || _getCurrentFolderId();
            if (target && typeof window.loadFolder === 'function') {
              window.loadFolder(target, false, 'open');
            }
          } catch(_e) {}
        }, 400);
      })
      .catch(function(e){
        console.error(e);
        if (elStatus) elStatus.textContent = 'ä¿å­˜å¤±æ•—';
        alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
      });
    } catch(e){
      console.error(e);
      alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
    }
  }

  (function wireBtn(){
    try {
      var b = document.getElementById('btnComposeSave');
      if (b && !b.__emlPatchBound) {
        b.__emlPatchBound = true;
        try { b.removeEventListener('click', _composeAndOpenPicker); }catch(_e){}
        b.addEventListener('click', _composeAndOpenPicker);
      }
    } catch(e){ console.error(e); }
  })();
})();
</script>